<!DOCTYPE HTML>
<html>

<head>
	<link rel="bookmark"  type="image/x-icon"  href="/img/v.png"/>
	<link rel="shortcut icon" href="/img/v.png">
	
			    <title>
    Hermann Cain
    </title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
    <link rel="stylesheet" href="/css/mic_main.css" />
    <link rel="stylesheet" href="/css/dropdownMenu.css" />
    <meta name="keywords" content="hermann" />
    
    <noscript>
        <link rel="stylesheet" href="/css/noscript.css" />
    </noscript>
    <style type="text/css">
        body:before {
          content: ' ';
          position: fixed;
          top: 0;
          background: url('/img/bg.jpg') center 0 no-repeat;
          right: 0;
          bottom: 0;
          left: 0;
          background-size: cover; 
        }
    </style>

			    
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script async type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


    <script src="/js/jquery.min.js"></script>
    <script src="/js/jquery.scrollex.min.js"></script>
    <script src="/js/jquery.scrolly.min.js"></script>
    <script src="/js/skel.min.js"></script>
    <script src="/js/util.js"></script>
    <script src="/js/main.js"></script>
	
<link rel="stylesheet" href="/css/prism-okaidia.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>
    
		
<!-- Layouts -->



<!--  代码渲染  -->
<link rel="stylesheet" href="/css/prism_okaidia.css" />
<link rel="stylesheet" href="/css/typo.css" />
<!-- 文章页 -->
<body class="is-loading">
    <!-- Wrapper 外包 s-->
    <div id="wrapper" class="fade-in">
        <!-- Intro 头部显示 s -->
        <!-- Intro 头部显示 e -->
        <!-- Header 头部logo start -->
        <header id="header">
    <a href="/" class="logo">HermannCain</a>
</header>
        <!-- Nav 导航条 start -->
        <nav id="nav" class="special" >
            <ul class="menu links" >
			<!-- Homepage  主页  --> 
			<li >
	            <a href="/" rel="nofollow">主页</a>
	        </li>
			<!-- categories_name  分类   --> 
	        
	        <li class="active">
	            <a href="#s1">分类</a>
	                    <ul class="submenu">
	                        <li>
	                        <a class="category-link" href="/categories/产业/">产业</a></li><li><a class="category-link" href="/categories/理论/">理论</a></li><li><a class="category-link" href="/categories/读文/">读文</a>
	                    </ul>
	        </li>
	        
	        <!-- archives  归档   --> 
	        
	        
		        <!-- Pages 自定义   -->
		        
		        <li>
		            <a href="/projects/" title="项目">
		                项目
		            </a>
		        </li>
		        
		        <li>
		            <a href="/tag/" title="标签">
		                标签
		            </a>
		        </li>
		        


            </ul>
            <!-- icons 图标   -->
			<ul class="icons">
		            
		                <li><a href="https://github.com/hermanncain" class="icon fa-github"><span class="label">GitHub</span></a></li>
		            
		            
		            
		            
			</ul>
</nav>

        <div id="main" >
            <div class ="post_page_title_img" style="height: 25rem;background-image: url(/img/ShapeAlgebra/ShapeAlgebra_w.png);background-position: center; background-repeat:no-repeat; background-size:cover;-moz-background-size:cover;overflow:hidden;" >
                <a href="#" style="padding: 4rem 4rem 2rem 4rem ;"><h2 >形状代数</h2></a>
            </div>
            <!-- Post -->
            <div class="typo" style="padding: 3rem;">
                <h2 id="1-形状"><a href="#1-形状" class="headerlink" title="1 形状"></a>1 形状</h2><h3 id="1-1-形状代数表"><a href="#1-1-形状代数表" class="headerlink" title="1.1 形状代数表"></a>1.1 形状代数表</h3><p>Stiny在1992年系统地提出了形状代数$U_{ij}$，对形状文法进行了扩展。</p>
<blockquote>
<p>理解形状代数需要离散数学的知识</p>
</blockquote>
<p>形状代数阶梯表</p>
<table>
<thead>
<tr>
<th>$U_{00}$</th>
<th>$U_{01}$</th>
<th>$U_{02}$</th>
<th>$U_{03}$</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>$U_{11}$</td>
<td>$U_{12}$</td>
<td>$U_{13}$</td>
</tr>
<tr>
<td></td>
<td></td>
<td>$U_{22}$</td>
<td>$U_{23}$</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>$U_{33}$</td>
</tr>
</tbody>
</table>
<p>代数$U_{ij}$ 的含义是在$j$维上操作$i$维形状。$i$维形状的边界是$U_{i-1,i}$中的形状，因为$i$维形状不能被小于$i-1$维的形状分割成更多部分：点分割线，线分割面，面分割体。形状是基本元素的有限集或空集。基本元素是<strong>极大元</strong>：任意两个基本元素彼此独立，不互相包含。</p>
<p>具体从包括的形状来说， $U_{0j}$ 是点， $U_{1j}$ 是线， $U_{2j}$ 是面， $U_{3j}$ 是体。所以阶梯表所包含的形状是：</p>
<table>
<thead>
<tr>
<th>点</th>
<th>线上的点</th>
<th>面上的点</th>
<th>体上的点</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>线</td>
<td>面上的线</td>
<td>体上的线</td>
</tr>
<tr>
<td></td>
<td></td>
<td>面</td>
<td>体上的面</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>体</td>
</tr>
</tbody>
</table>
<h3 id="1-2-形状代数运算"><a href="#1-2-形状代数运算" class="headerlink" title="1.2 形状代数运算"></a>1.2 形状代数运算</h3><p>使用$\{R\}_U$表示关系运算，则</p>
<ul>
<li>$U_{ij}$中的形状通过<strong>蕴含</strong>$\leq _U$关系运算而形成<strong>偏序集</strong>（即某些形状可能是另一些形状的一部分，也可能不是）；</li>
<li><p>通过布尔关系运算<strong>和</strong>$+_U$，<strong>差</strong>$-_U$组合，形成有补分配格。</p>
<p>$U_{ij}$在j维的欧式变换下是封闭的。</p>
</li>
</ul>
<p>极大元、蕴含、和、差可以有多种定义方式：</p>
<ul>
<li><p>一种是直接通过<strong>嵌入</strong>定义，这是基本元素的基本关系。例如一条短线嵌入在另一条长线中。但这种关系太过于基本了，导致实现上述那些运算比较复杂且内隐；</p>
</li>
<li><p>另一种方法是显式定义。按照基本元素的嵌入关系，构造化简规则，定义上述运算。和或者差就可以用来定义蕴含。</p>
</li>
</ul>
<h2 id="2-标记"><a href="#2-标记" class="headerlink" title="2 标记"></a>2 标记</h2><p>和形状文法中的标记一样，定义和形状的定义是类似的。标记用于区分相同的形状，或建立不同形状的联系。</p>
<p>标记代数是标记表中的标记、布尔运算组成的代数系统，对欧式变换封闭。$V_{ij}$就将标记和形状结合到一起，形成新的代数系统。标记形状记为$(e,a)$，其中e是$U_{ij}$中的形状，a是标记。</p>
<h2 id="3-权重"><a href="#3-权重" class="headerlink" title="3 权重"></a>3 权重</h2><p>这里从视觉效果给点加上了半径，线加上了粗细，面和体加上了填充色——这些就是权重。</p>
<p>权重也可以进行运算。布尔和显然是取了权重大的部分和剩下的部分，如细线和粗线有一部分重合，那么布尔和结果就是全部粗线和细线剩下的部分，即$u+v=\max \{ u,v \}$。布尔差的定义则要复杂一些，对于 $u-v$，如果 $u&gt;v$，则结果就是代数差；否则为0。</p>
<p><img src="/img/ShapeAlgebra/ShapeAlgebra_w.png" alt="带权形状的布尔和"></p>
<h2 id="4-带权形状"><a href="#4-带权形状" class="headerlink" title="4 带权形状"></a>4 带权形状</h2><p>将标记引入形状得到标记性状，那么将权重引入形状则得到带权形状代数$W_{ij}$。从权重的定义已经可以看到带权形状代数的性质。</p>
<p>这样，便将形状、标记、权重统一在了一个理论框架内，其中的运算为蕴含、布尔和、布尔差，欧式变换。U,V,W可以进行组合，形成更复杂的结果。</p>
<h2 id="5-形状文法"><a href="#5-形状文法" class="headerlink" title="5 形状文法"></a>5 形状文法</h2><p>有了形状代数的定义，形状文法就可以在其基础上扩展了。形状规则$A \to B$作用于形状C时，其运算机制为$[C -_X t(A)] +_X t(B)$，其中$-_X$是X上的布尔差运算，$+_X$是X上的布尔和运算，X是U,V,W中的任何一个。</p>
<p>参数化形状文法中，A(x)是形状框架，x是变量的有限集（可以是空集）。F决定变量x的取值。单一的U,V,W代数中，变量的取值是基本形状，或标记形状/带权形状的有序对；由U,V,W组合而成的代数中，变量的取值可以使多种类型的有序对。</p>
<p>带权形状$W_{ij}$中，F给A(x)中变量的赋值是基本元素和权重的有序对(e,u)。但此时F[A(x)]可能不是形状（为什么？）。此时，令$A(i + 1) = A(i) +_W \{(e_{i+1}, u_{i+1})\}, A(0)=\varnothing$。通过此布尔和递推公式确保F[A(x)]是形状。</p>
<h2 id="6-扩展"><a href="#6-扩展" class="headerlink" title="6 扩展"></a>6 扩展</h2><h3 id="6-1-非直线形状和嵌入空间"><a href="#6-1-非直线形状和嵌入空间" class="headerlink" title="6.1 非直线形状和嵌入空间"></a>6.1 非直线形状和嵌入空间</h3><p>Jowers指出，$U_{ij}$形状代数实际上是直线形状（维度为i）嵌入到不同维度欧式空间中（维度为j）。这会带来一些问题：</p>
<ul>
<li>直线形状是自相似的，直线可以以无限的方式嵌入（欧式变换）到另一直线中，任意两直线（方形平面、立方体等）互为子集；但是对于非直线形状，如圆弧，必须是短圆弧才可以嵌入到长圆弧，虽然嵌入放肆无限，但互为子集不成立。抛物线更甚——嵌入的方式都已经不是有限的了（只有两种方法，即嵌入到轴对称的两个位置）。</li>
</ul>
<p><img src="/img/ShapeAlgebra/ShapeAlgebra_embedding.png" alt="直线形状和非直线形状的嵌入"></p>
<ul>
<li>视觉嵌入和解析嵌入对直线形状是绝大部分时候是相同的，但对于非直线形状，除非解析式相同，否则视觉嵌入和解析嵌入不可能相同。虽然大牛Ramesh Krishnamurti提倡能够清晰描述形状的解析嵌入，但视觉上的相似在设计中很重要。而为了统一二者，只能通过样条曲线拟合或计算机视觉的方法来实现，不过尚未对形状代数进行扩展。</li>
</ul>
<p><img src="/img/ShapeAlgebra/ShapeAlgebra_va.png" alt="视觉嵌入vs解析嵌入"></p>
<p>更进一步，考虑非欧空间的情况，比如圆锥空间，直线可以仅通过旋转就和各种圆锥曲线互相转化。</p>
<p><img src="/img/ShapeAlgebra/ShapeAlgebra_c.png" alt="圆锥空间"></p>
<p>这些都是$U_{ij}$所不包括的内容。所以形状代数有待进一步发展完善。</p>
<h3 id="6-2-形状分解"><a href="#6-2-形状分解" class="headerlink" title="6.2 形状分解"></a>6.2 形状分解</h3><p>可以用有限元素将一个形状进行分解，于是可以用有限的部件集来描述形状的分解。于是问题就来了：</p>
<ul>
<li>集合可以通过交并差来扩展（我认为这不是问题，作者也没有详细讨论）；</li>
<li>形状的分解从哪里来？计算。计算生成形状。传统的CAD系统都是用形状分解出来的部件来描述形状。不过Jowers认为，并不是所有的计算都生成形状。</li>
</ul>
<p>关于形状分解从哪里来，我有一些自己的想法，将在以后进行介绍。</p>
<hr>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1] Stiny G. Weights. Environment and Planning B: Planning and Design. 192. 19: 413-430.</p>
<p>[2] Jowers I, Earl C. Extending the Algebras of Design. Nexus Network Journal. 2015. 17(3): 947-962.</p>
<p>[3] Jowers I, Earl C, Stiny G. Shape Computations Without Compositions. International Conference on Computer-Aided Architectural Design Futures. Singapore. 2017: 348-365.</p>

            </div>

            <!-- Post Comments -->
            

        </div>
        <!-- Copyright 版权 start -->
                <div id="copyright">
            <ul>
                <li>&copy;Powered By <a href="https://hexo.io/zh-cn/" style="border-bottom: none;">hexo</a></li>
                <li>Design: <a href="http://miccall.tech " style="border-bottom: none;">miccall</a></li>
            </ul>
            
				<span id="busuanzi_container_site_pv"> 2018 </span> 
			
        </div>
    </div>
</body>



 	
</html>
